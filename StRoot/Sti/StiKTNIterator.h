//StiKTNIterator.h
//M.L. Miller (Yale Software)
//12/01

/*! \class StiKTNIterator
  This class is an STL compliant forward iterator that will traverse from
  the leaf of a tree upward to a root.

  \author M.L. Miller (Yale Software)
  \note We use the defualt copy/assignment generated by compiler.
  \note Singularity (i.e., 'end') is represented by setting mNode=0.
  \note StiKTNIterator is a non-virtual class.
*/
#ifndef StiKTNIterator_HH
#define StiKTNIterator_HH

#include <assert.h>
#include "StiKalmanTrackNode.h"
typedef StiKalmanTrackNode KTN_t;
class StiKTNIterator;
typedef StiKTNIterator StiKTNBidirectionalIterator;


//This is a temp hack to get around old gcc ansi-non-compliant STL implementation
class StiKTNIterator
{
public:
    
    ///ctr-dstr
    StiKTNIterator(KTN_t* leaf=0,int dir=0) : mDir(dir),mNode( leaf) {};
    StiKTNIterator(KTN_t& leaf  ,int dir=0) : mDir(dir),mNode(&leaf) {};
    StiKTNIterator   begin();
    StiKTNIterator  rbegin();

    ///equality:
    bool operator==(const StiKTNIterator& rhs) const;

    ///inequlity
    bool operator!=(const StiKTNIterator& rhs) const;

    ////Dereference
    KTN_t& operator*();
    KTN_t* operator()();
    
    ///prefix
    StiKTNIterator& operator++ ();
    
    ///postfix
    StiKTNIterator operator++(int);

    ///prefix
    StiKTNIterator& operator-- ();
    
    ///postfix
    StiKTNIterator operator--(int);

    ///We demarcate the end of the traversal via  a singular iterator
static const StiKTNIterator&  end();
static const StiKTNIterator& rend();

static    StiKTNIterator   begin(KTN_t* fist);
static    StiKTNIterator  rbegin(KTN_t* last);


private:
    int mDir;
    KTN_t* mNode;
};

class StiKTNForwardIterator: public StiKTNIterator{
public:
    StiKTNForwardIterator(KTN_t* leaf=0) : StiKTNIterator(leaf,1){};
    StiKTNForwardIterator(KTN_t& leaf  ) : StiKTNIterator(leaf,1){};
static const StiKTNForwardIterator& end();
};

//inlines --

inline bool StiKTNIterator::operator==(const StiKTNIterator& rhs) const
{
    return mNode==rhs.mNode;
}

inline bool StiKTNIterator::operator!=(const StiKTNIterator& rhs) const
{
    return !(mNode==rhs.mNode);
}

inline KTN_t& StiKTNIterator::operator*()
{
    return *mNode;
}
inline KTN_t* StiKTNIterator::operator()()
{
    return mNode;
}

//prefix
/*! In the case where the prefix operator increments beyond the root of the tree,
  the pointer to mNode is set to 0.   This demarcates the end of the traversal.
 */
inline StiKTNIterator& StiKTNIterator::operator-- ()
{
    mDir = !mDir;
    ++(*this);
    mDir = !mDir;
    return *this;
}
    

//postfix
/*! In the case where the prefix operator increments beyond the root of the tree,
  the pointer to mNode is set to 0.   This demarcates the end of the traversal.
*/
inline StiKTNIterator StiKTNIterator::operator++(int)
{
    StiKTNIterator temp = *this;
    ++(*this);
    return temp;
}

//prefix
/*! In the case where the prefix operator increments beyond the last leaf of the tree,
  the pointer to mNode is set to -.  This demarcates the end of traversal.
*/
inline StiKTNIterator& StiKTNIterator::operator++ ()
{
  assert(mNode);
  if(!mDir) { //forward direction  

    mNode = static_cast<KTN_t*>(mNode->getNextNode());

  } else { //backward direction

    mNode = static_cast<KTN_t*>(mNode->getPrevNode());
  }

  return *this;
}

//postfix decrement
/*! In the case where the prefix operator increments beyond the root of the tree,
  the pointer to mNode is set to 0.   This demarcates the end of the traversal.
*/
inline StiKTNIterator StiKTNIterator::operator--(int)
{
    StiKTNIterator temp = *this;
    --(*this);
    return temp;
}


inline StiKTNIterator  StiKTNIterator::begin(KTN_t* fist)
{
  return StiKTNIterator(fist,0);
}  

inline StiKTNIterator StiKTNIterator::rbegin(KTN_t* last)
{
  return StiKTNIterator(last,1);
}  
inline StiKTNIterator  StiKTNIterator::begin()
{
  assert(mNode);
  KTN_t*  fist = (KTN_t*)mNode->getFirstNode();
  return StiKTNIterator(fist,0);
}  

inline StiKTNIterator StiKTNIterator::rbegin()
{
  assert(mNode);
  KTN_t* last = (KTN_t*)mNode->getLastNode();
  return StiKTNIterator(last,1);
}  

#endif
