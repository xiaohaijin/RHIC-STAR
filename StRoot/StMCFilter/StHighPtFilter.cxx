// @(#)root/eg:$Id: StHighPtFilter.cxx,v 1.1 2011/01/25 20:06:53 jwebb Exp $
// Author: Victor Perev  17/03/2009

//______________________________________________________________________________
#include "stdlib.h"
#include "math.h"
#include <iostream>
#include <fstream>

#include "StHighPtFilter.h"
#include "StGenParticle.h"

using namespace std;

/// 	IMPORTANT IMPORTANT IMPORTANT
/// Defining the static instance of user filter provides creating this
/// class during the loading of library. Afterward GEANT could select 
/// the needed filter by name. 
/// more info in http://www.star.bnl.gov/~perev/SIM/mcFilter.pdf

static StHighPtFilter particleFilter;

/// StMCFilter base class is :
/// 1. A user interface. User must overload functions:
/// 	a)RejectEG (StGenParticles &) ? called inside Pythia. Interaction point
/// 	  in (0,0,0); EG == EventGenerator
/// 	b)RejectGT (StGenParticles &) ? called inside Geant before tracking.
/// 	  Interaction point generated by Geant; GT==GeantTracking
/// 	c)RejectGE (StGenParticles &) ? called inside Geant after tracking;
/// 	  GE==GeantEnd
/// 2. All three methods have exactly the same input arguments;
/// 3. User must provide the unique name of the his filter. Selection of filter is
///    based on this name.
/// 4. Apart of that in this base class all the machinery of connection to Pythia
///    and Geant is hidden
/// 5. At the end Finish() is called. Print statistics. Could be overloaded
/// 
/// An argument of RejectXX(StGenParticles &Ptl)
/// Class StGenParticles is a container class containing StGenParticle objects.
/// Each object represents one particle(track). User methods of StGenParticles
/// class:
/// 1. Ptl.Size() ? number of particles;
/// 2. Ptl(index) ? pointer to particle (StGenParticle*)
/// 3. Ptl.Print() ? print all particles;
/// 4. Ptl.Print(char* tit) ? print container
/// 
/// Class StGenParticle ideologically is based on HEPEVT standard
/// http://cepa.fnal.gov/psm/simulation/mcgen/lund/pythia_manual/pythia6.3/pythia6301/node39.html
/// 
/// Methods:
///   - int GetStatusCode; 			/// 1= final particle
///   - int GetPdgCode; 			//PDG particle code
///   - int GetGeaCode(); 			//Geant particle code
///   - StGenParticle *GetMother(int i); 	//mother particle(0=beam,1=target)
///   - StGenParticle *GetDaughter(int i); 	//daughter ith particle
///   - double GetCalcMass ();		//calculated mass
///   - double GetMass(); 			//mass
///   - int GetNDaughters
///   - void Momentum(double p4[4]); //four momentum
///   - void Vertex(double v[3]) //vertex in cm;
///   - double Time(); //time in cm
///   - int IsPrimary(); //Is this particle a primary one?
///   - int IsFinal () //Is this particle a final one?
/// 
/// Additional methods:
///   - double R (); //Rxy of vertex
///   - double Rho (); //Rxyz of vertex
///   - double P (); /// Full momentum
///   - double Pt (); //Transverse momentum
///   - double Energy();
///   - double Eta (); //Pseudo rapidity
///   - double Phi ();
///   - double Theta ();
/// 
///     		Filter kumac commands
/// 	gexec $STAR_LIB/geometry.so
/// 	gexec $STAR_LIB/libpythia_6410t.so
/// 	gexec $STAR_LIB/bpythia.so
/// 	gexec $STAR_LIB/StMCFilter.so
/// 	gfilter filterName
/// All three methods are called in a proper places. Method which is not
/// overloaded, always returns zero (no rejection)
/// 

StHighPtFilter::StHighPtFilter():StMCFilter("highpt")
{
  
  mPtCut  = 2.5;
  mEtaCut = 1.2;
  readConfig();
  std::cout << "======================================================" << std::endl;
  std::cout << "highpt hadron filter initialized" << std::endl;
  std::cout << "PtCUT:  " << mPtCut  << std::endl;
  std::cout << "EtaCUT: " << mEtaCut << std::endl;
  std::cout << "======================================================" << std::endl;
};

void StHighPtFilter::readConfig()
{
  ifstream cfile("highpt.cnf");
  while (1) {
    string   key;
    double   value;
    cfile >> key >> value;
    if ( !cfile.good() ) break; // EOF or no file
    parseConfig( key, value );
  }
}

void StHighPtFilter::parseConfig(string key, double value)
{
  if ( key=="PtCUT"  ){ mPtCut  = value; }
  if ( key=="EtaCUT" ){ mEtaCut = value; }
  return;
}


//______________________________________________________________________________
int StHighPtFilter::RejectEG(const StGenParticleMaster &ptl) const
{
  //ptl.Print("************** In RejectEG ************** ");
  //cout<<"********************** In RejectEG ******************"<<endl;
  return 0;
}
//______________________________________________________________________________
int StHighPtFilter::RejectGT(const StGenParticleMaster &ptl) const
{

  const StGenParticle *tk=0;
  int n = ptl.Size();

  //
  // Loop over all particles and accept events with high pT
  // charged hadrons (pi+/-, K+/- and p/pbar) within |y|<1.2
  // and with pT > 2.5 GeV.  The |y|<1.2 cut is consistent
  // with  vertex cuts of |z|<100 cm.
  //
  float maxPt = 0.; 

  for (int i=0;i<n;i++) {

    tk = ptl(i); if (!tk)       continue;
    if (tk->GetStatusCode()!=1) continue;
    if( fabs(tk->Eta())> mEtaCut ) continue;  //Jason's suggestion@Jan13th2011

    if ( tk->Pt() < mPtCut ) continue;

    if( (fabs(tk->GetPdgCode())==211 || 
	 fabs(tk->GetPdgCode())==321 || 
	 fabs(tk->GetPdgCode())==2212) ) return 0; // accept on any charged hadron with pT > threshold

  }

  return 1; // No charged tracks with pT > threshold


}
//______________________________________________________________________________
int StHighPtFilter::RejectGE(const StGenParticleMaster &ptl) const
{
  //ptl.Print("************** In RejectGE ************** ");
  return 0;
}
