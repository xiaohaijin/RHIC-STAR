//$Id: haddWana.C,v 1.18 2010/05/19 20:49:50 balewski Exp $
// line added after tag=DNP2009 by Jan
// run list chaned to match final run selection for SL09g 

#include <string.h>
#include "TChain.h"
#include "TFile.h"
#include "TH1.h"
#include "TTree.h"
#include "TKey.h"
#include "Riostream.h"

TList *FileList;
TFile *Target;


int isAPS2010pol=0; /* affects only setP1-P4, not setA-D,
		       set it to 0 to see all usable polarized fills */



void MergeRootfile( TDirectory *target, TList *sourcelist );

void haddWanaX() {
  haddWana("run9setA");
  haddWana("run9setB");
  haddWana("run9setC");
  haddWana("run9setD");
  haddWana("run9setABCD");
}

void haddWana() {
  haddWana("run9setP1");
  haddWana("run9setP2");
  haddWana("run9setP3");
  haddWana("run9setP4");
  haddWana("run9setP1234");
}

void haddWana(char *set,TString iPath="/star/data05/scratch/balewski/2009-Wana-SL09g-a3/data/") {
  // iPath="/star/institutions/mit/balewski/freezer/2009-Wana-SL09g-may3-PRL/data/";
  TString out=iPath;

  if(strstr("F10505",set)>0) {
    char *runL=" R10096141 R10097003 R10097004 R10097005 R10097008";
  } else if(strstr("run9setA",set)>0) {
    char *runL="R10078077 R10078078 R10078081 R10078082 R10078092 R10078093 R10078094 R10079002 R10079004 R10079005 R10079006 R10079007 R10079015 R10079016 R10079017 R10079027 R10079028 R10079030 R10079031 R10079033 R10079034 R10079035 R10079040 R10079042 R10079045 R10079046 R10079047 R10079049 R10079050 R10079057 R10079059 R10079060 R10079061 R10079062 R10079063 R10079069 R10079070 R10079071 R10079074 R10079078 R10079079 R10079080 R10079081 R10079129 R10079130 R10079131 R10079135 R10079137 R10079138 R10079139 R10080019 R10080020 R10080022 R10080040 R10080042 R10080061 R10080062 R10080076 R10080077 R10080078 R10080080 R10080081 R10081007 R10081013 R10081026 R10081027 R10081047 R10081053 R10081055 R10081056 R10081096 R10081102 R10081104 R10081107 R10081108 R10081110 R10081111 R10081112 R10081115 R10081117 R10082003 R10082005 R10082008 R10082011 R10082018 R10082021 R10082022 R10082027 R10082029 R10082031 R10082032 R10082035 R10082043 R10082071 R10082072 R10082073 R10082074 R10082075 R10082076 R10082077 R10082078 R10082083 R10082085 R10082091 R10082092 R10082093 R10082095 R10083013 R10083018 R10083019 R10083026 R10083027 R10083028 R10083032 R10083033 R10083034 R10083037 R10083040 R10083041 R10083045 R10083047 R10083052 R10083053 R10083054 R10083055 R10083056 R10083058 R10084010 R10084011 R10084021 R10084022 R10084024 R10085016 R10085017 R10085018 R10085019 R10085023 R10085024 R10085025 R10085026 R10085027 R10085028 R10085029 R10085030 R10085031 R10085032 R10085038 R10085039 R10085104 R10085107 R10085108 R10085109 R10085113 R10085114 R10085115 R10085131 R10085132 R10085133 R10085134 R10085135 R10085136 R10085140 R10086001 R10086007 R10086008 R10086015 R10086022 R10086023 R10086024 R10086037 R10086043 R10086044 R10086046"; //total for setA 179
  } else if(strstr("run9setB",set)>0) {
    char *runL="R10087001 R10087009 R10087011 R10087012 R10087018 R10087020 R10087021 R10087022 R10087023 R10087025 R10087028 R10087031 R10087032 R10087033 R10087034 R10087035 R10087036 R10087037 R10087041 R10087051 R10087052 R10087053 R10087054 R10087057 R10087058 R10087059 R10087062 R10087063 R10087065 R10087067 R10087069 R10087070 R10087071 R10087077 R10087078 R10087082 R10087084 R10087085 R10087088 R10087094 R10087096 R10087097 R10087114 R10087117 R10087119 R10087125 R10087126 R10088001 R10088010 R10088011 R10088013 R10088022 R10088024 R10088026 R10088027 R10088028 R10088029 R10088030 R10088031 R10088036 R10088058 R10088062 R10088063 R10088069 R10088070 R10088071 R10088075 R10088077 R10088081 R10088084 R10088085 R10088096 R10088102 R10088110 R10088111 R10088112 R10088113 R10088120 R10088121 R10089001 R10089004 R10089008 R10089010 R10089011 R10089015 R10089016 R10089019 R10089021 R10089023 R10089079 R10089080 R10089081 R10090001 R10090004 R10090005 R10090008 R10090013 R10090015 R10090017 R10090018 R10090019 R10090020 R10090022 R10090026 R10090027 R10090037 R10090038 R10090040 R10090042 R10090046 R10090047 R10090072 R10090074 R10090076 R10090079 R10090080 R10090081 R10090089 R10090095 R10090100 R10090108 R10090109 R10090111 R10090112 R10091089 R10091090 R10092002 R10092004 R10092009 R10092011 R10092021 R10092022 R10092023 R10092024 R10092027 R10092028 R10092029 R10092030 R10092031 R10092033 R10092034 R10092036 R10092037 R10092038 R10092039 R10092040 R10092042 R10092046 R10092047 R10092048 R10092049 R10092050 R10092084 R10092098 R10092102 R10092105 R10092107 R10093082 R10093083 R10093084 R10093131 R10094003 R10094005 R10094006 R10094007 R10094016 R10094019 R10094021 R10094022 R10094023 R10094024 R10094063 R10094067 R10094071 R10094073 R10094078 R10094084 R10094088 R10094089 R10094090 R10094092 R10094095 R10094096 R10094098 R10094099 R10094100 R10095022 R10095023 R10095024 R10095030 R10095036 R10095037 R10095039 R10095040 R10095041 R10095045 R10095046 R10095047 R10095048 R10095049 R10095050 R10095051 R10095052 R10095056 R10095057 R10095120 R10095121 R10095122 R10095125 R10096001 R10096002 R10096005 R10096006 R10096007 R10096008 R10096009 R10096014 R10096015 R10096019 R10096024 R10096025 R10096026 R10096027"; //total for setB:  223 
  } else if(strstr("run9setC",set)>0) {
    char *runL=" R10096141 R10097003 R10097004 R10097005 R10097008 R10097012 R10097016 R10097019 R10097021 R10097022 R10097026 R10097028 R10097029 R10097030 R10097038 R10097040 R10097044 R10097045  R10097087  R10097089  R10097091 R10097102 R10097104 R10097106 R10097108 R10097110 R10097117 R10097118 R10097137 R10097140 R10097145 R10097146 R10097149 R10097153 R10098029 R10098035 R10098038 R10098040 R10098045 R10099028 R10099029 R10099055 R10099057 R10099066 R10099067 R10099071 R10099073 R10099074 R10099076 R10099077 R10099078 R10099185 R10099186 R10099187 R10099188 R10099189 R10099194 R10099195 R10100005 R10100006 R10100008 R10100013 R10100014 R10100015 R10100016 R10100017 R10100021 R10100028 R10100029 R10100032 R10100067 R10100068 R10100070 R10100071 R10100072 R10100077 R10100079 R10100081 R10100093 R10100095 R10100098 R10100164 R10100165 R10100166 R10100167 R10100169 R10100172 R10100175 R10100176 R10100177 R10100178 R10100179 R10100180 R10101001 R10101005 R10101006 R10101008 R10101009 R10101011 R10101016 R10101017 R10101018 R10101019 R10101020"; //total:  109 
   } else if(strstr("run9setD",set)>0) {
    char *runL="R10101028 R10101029 R10101030 R10101037 R10101038 R10101039 R10101040 R10101059 R10101060 R10101061 R10101064 R10101065 R10101069 R10101070 R10101071 R10101074 R10101075 R10101076 R10101078 R10101081 R10101082 R10101083 R10101086 R10101088 R10101089 R10101090 R10101091 R10101092 R10101093 R10101094 R10102003 R10102031 R10102033 R10102036 R10102037 R10102039 R10102045 R10102046 R10102048 R10102050 R10102051 R10102055 R10102056 R10102062 R10102063 R10102065 R10102066 R10102069 R10102070 R10102094 R10102095 R10102096 R10102098 R10102100 R10102104 R10102105 R10102107 R10102108 R10102109 R10102110 R10102112 R10103001 R10103007 R10103008 R10103010 R10103011 R10103012 R10103015 R10103016 R10103017 R10103018 R10103027 R10103028 R10103031 R10103033 R10103034 R10103041 R10103042"; //total:  78
  } else if(strstr("run9setABCD",set)>0) {
    char *runL="run9setA run9setB run9setC  run9setD "; //total 589 for setABCD
  } else if(strstr("run9setP1",set)>0) {
    char *runL="R10083013 R10083018 R10083019 R10083026 R10083027 R10083028 R10083032 R10083033 R10083034 R10083037 R10083040 R10083041 R10083045 R10083047 R10083052 R10083053 R10083054 R10083055 R10083056 R10083058 R10087051 R10087052 R10087053 R10087054 R10087057 R10087058 R10087059 R10087062 R10087063 R10087065 R10087067 R10087069 R10087070 R10087071 R10087077 R10087078 R10087082 R10087084 R10087085 R10087088 R10087094 R10087096 R10087097 R10093131 R10094003 R10094005 R10094006 R10094007 R10094016 R10094019 R10094021 R10094022 R10094023 R10094024  R10097087  R10097089  R10097091 R10097102 R10097104 R10097106 R10097108 R10097110 R10097117 R10097118 R10097137 R10097140 R10097145 R10097146 R10097149 R10097153 R10100067 R10100068 R10100070 R10100071 R10100072 R10100077 R10100079 R10100081 R10100093 R10100095 R10100098 R10102031 R10102033 R10102036 R10102037 R10102039 R10102045 R10102046 R10102048 R10102050 R10102051 R10102055 R10102056 R10102062 R10102063 R10102065 R10102066 R10102069 R10102070"; //total:  102
  } else if(strstr("run9setP2",set)>0) {
    char *runL="R10084010 R10084011 R10084021 R10084022 R10084024 R10085016 R10085017 R10085018 R10085019 R10085023 R10085024 R10085025 R10085026 R10085027 R10085028 R10085029 R10085030 R10085031 R10085032 R10085038 R10085039 R10087114 R10087117 R10087119 R10087125 R10087126 R10088001 R10088010 R10088011 R10088013 R10088022 R10088024 R10088026 R10088027 R10088028 R10088029 R10088030 R10088031 R10088036 R10089079 R10089080 R10089081 R10090001 R10090004 R10090005 R10090008 R10090013 R10090015 R10090017 R10090018 R10090019 R10090020 R10090022 R10090026 R10090027 R10091089 R10091090 R10092002 R10092004 R10092009 R10092011 R10092021 R10092022 R10092023 R10092024 R10092027 R10092028 R10092029 R10092030 R10092031 R10092033 R10092034 R10092036 R10092037 R10092038 R10092039 R10092040 R10092042 R10092046 R10092047 R10092048 R10092049 R10092050 R10094063 R10094067 R10094071 R10094073 R10094078 R10094084 R10094088 R10094089 R10094090 R10094092 R10094095 R10094096 R10094098 R10094099 R10094100 R10098029 R10098035 R10098038 R10098040 R10098045 R10100164 R10100165 R10100166 R10100167 R10100169 R10100172 R10100175 R10100176 R10100177 R10100178 R10100179 R10100180 R10101001 R10101005 R10101006 R10101008 R10101009 R10101011 R10101016 R10101017 R10101018 R10101019 R10101020 R10102094 R10102095 R10102096 R10102098 R10102100 R10102104 R10102105 R10102107 R10102108 R10102109 R10102110 R10102112 R10103001 R10103007 R10103008 R10103010 R10103011 R10103012 R10103015 R10103016 R10103017 R10103018 R10103027 R10103028 R10103031 R10103033 R10103034 R10103041 R10103042"; //total:  155
  } else if(strstr("run9setP3",set)>0) {
    char *runL="R10081007 R10081013 R10081026 R10081027 R10081047 R10081053 R10081055 R10081056 R10085104 R10085107 R10085108 R10085109 R10085113 R10085114 R10085115 R10085131 R10085132 R10085133 R10085134 R10085135 R10085136 R10085140 R10086001 R10086007 R10086008 R10086015 R10086022 R10086023 R10086024 R10086037 R10086043 R10086044 R10086046 R10088058 R10088062 R10088063 R10088069 R10088070 R10088071 R10088075 R10088077 R10088081 R10088084 R10088085 R10092084 R10092098 R10092102 R10092105 R10092107 R10095022 R10095023 R10095024 R10095030 R10095036 R10095037 R10095039 R10095040 R10095041 R10095045 R10095046 R10095047 R10095048 R10095049 R10095050 R10095051 R10095052 R10095056 R10095057 R10095120 R10095121 R10095122 R10095125 R10096001 R10096002 R10096005 R10096006 R10096007 R10096008 R10096009 R10096014 R10096015 R10096019 R10096024 R10096025 R10096026 R10096027 R10099028 R10099029 R10099055 R10099057 R10099066 R10099067 R10099071 R10099073 R10099074 R10099076 R10099077 R10099078 "; //total:  111 -sth
  } else if(strstr("run9setP4",set)>0) {
    char *runL="R10081096 R10081102 R10081104 R10081107 R10081108 R10081110 R10081111 R10081112 R10081115 R10081117 R10082003 R10082005 R10082008 R10082011 R10082018 R10082021 R10082022 R10082027 R10082029 R10082031 R10082032 R10082035 R10082043 R10082071 R10082072 R10082073 R10082074 R10082075 R10082076 R10082077 R10082078 R10082083 R10082085 R10082091 R10082092 R10082093 R10082095 R10087001 R10087009 R10087011 R10087012 R10087018 R10087020 R10087021 R10087022 R10087023 R10087025 R10087028 R10087031 R10087032 R10087033 R10087034 R10087035 R10087036 R10087037 R10087041 R10088096 R10088102 R10088110 R10088111 R10088112 R10088113 R10088120 R10088121 R10089001 R10089004 R10089008 R10089010 R10089011 R10089015 R10089016 R10089019 R10089021 R10089023 R10090072 R10090074 R10090076 R10090079 R10090080 R10090081 R10090089 R10090095 R10090100 R10090108 R10090109 R10090111 R10090112 R10093082 R10093083 R10093084  R10096141 R10097003 R10097004 R10097005 R10097008 R10097012 R10097016 R10097019 R10097021 R10097022 R10097026 R10097028 R10097029 R10097030 R10097038 R10097040 R10097044 R10097045 R10099185 R10099186 R10099187 R10099188 R10099189 R10099194 R10099195 R10100005 R10100006 R10100008 R10100013 R10100014 R10100015 R10100016 R10100017 R10100021 R10100028 R10100029 R10100032 R10101059 R10101060 R10101061 R10101064 R10101065 R10101069 R10101070 R10101071 R10101074 R10101075 R10101076 R10101078 R10101081 R10101082 R10101083 R10101086 R10101088 R10101089 R10101090 R10101091 R10101092 R10101093 R10101094 R10102003"; //total:  153
  } else if(strstr("run9setP1234",set)>0) {
    char *runL="run9setP1 run9setP2 run9setP3 run9setP4"; //total:  NNN 
  } else if(strstr("setXX",set)>0) {
    char *runL="HHHHH "; //total:  NNN 
   } else {
    printf(" hadd: set=%s= NOT found, quit\n",set); return; }
  printf(" hadd: set=%s= path=%s= ...\n",set,iPath.Data());  
  out+=set;
  Target = TFile::Open( out+".wana.hist.root", "RECREATE" );
  FileList = new TList();
  printf("sum Output '%s' \n",Target->GetName());

  char *run=strtok(runL," "); // init 'strtok'
  int i=1;
  do {
    printf("add run %d '%s' \n",i++,run);
    if(isAPS2010pol && strstr(set,"run9setP")>0 ) { // remove runs from fills w/o official pol for APS-2010
      int irun=atoi(run+1);
      if(irun>=10083013 && irun<=10083058) { printf("\tdrop %s from F10415\n",run); continue;}
      if(irun>=10098015 && irun<=10098015) { printf("\tdrop %s from F10508\n",run); continue;}
    }
    TString fullName=iPath+run+".wana.hist.root";  
    FileList->Add( TFile::Open(fullName));
  } while(run=strtok(0," "));  // advance by one nam

  MergeRootfile(  Target, FileList );
  printf("finished Output '%s' \n",Target->GetName());

}   

void MergeRootfile(  TDirectory *target, TList *sourcelist ) {

  cout << "Target path: " << target->GetPath() << endl;
  TString path( (char*)strstr( target->GetPath(), ":" ) );
  path.Remove( 0, 2 );

  TFile *first_source = (TFile*)sourcelist->First();
  first_source->cd( path );
  TDirectory *current_sourcedir = gDirectory;

  int nh=0;
  // loop over all keys in this directory
  TChain *globChain = 0;
  TIter nextkey( current_sourcedir->GetListOfKeys() );
  TKey *key;
  while ( (key = (TKey*)nextkey())) {
    const char *name=key->GetName();
    nh++;
    if(nh%100==0) printf("nh=%d addingX %s\n",nh,name);
    
    // read object from first source file
    first_source->cd( path );
    TObject *obj = key->ReadObj();
    
    if ( obj->IsA()->InheritsFrom( "TH1" ) ) {
      // descendant of TH1 -> merge it
      
      //      cout << "Merging histogram " << obj->GetName() << endl;
      TH1 *h1 = (TH1*)obj;

      // loop over all source files and add the content of the
      // correspondant histogram to the one pointed to by "h1"
      TFile *nextsource = (TFile*)sourcelist->After( first_source );
      while ( nextsource ) {
        
        // make sure we are at the correct directory level by cd'ing to path
        nextsource->cd( path );
        TH1 *h2 = (TH1*)gDirectory->Get( h1->GetName() );
        if ( h2 ) {
          h1->Add( h2 );
          delete h2; // don't know if this is necessary, i.e. if 
                     // h2 is created by the call to gDirectory above.
        }

        nextsource = (TFile*)sourcelist->After( nextsource );
      }
    }
    else if ( obj->IsA()->InheritsFrom( "TTree" ) ) {
      
      // loop over all source files create a chain of Trees "globChain"
      const char* obj_name= obj->GetName();

      globChain = new TChain(obj_name);
      globChain->Add(first_source->GetName());
      TFile *nextsource = (TFile*)sourcelist->After( first_source );
      //      const char* file_name = nextsource->GetName();
      // cout << "file name  " << file_name << endl;
     while ( nextsource ) {
     	  
       globChain->Add(nextsource->GetName());
       nextsource = (TFile*)sourcelist->After( nextsource );
     }
     
    } else if ( obj->IsA()->InheritsFrom( "TDirectory" ) ) {
      // it's a subdirectory
      
      cout << "Found subdirectory " << obj->GetName() << endl;
      
      // create a new subdir of same name and title in the target file
      target->cd();
      TDirectory *newdir = target->mkdir( obj->GetName(), obj->GetTitle() );

      // newdir is now the starting point of another round of merging
      // newdir still knows its depth within the target file via
      // GetPath(), so we can still figure out where we are in the recursion
      MergeRootfile( core,newdir, sourcelist );
      
    } else {
      
      // object is of no type that we know or can handle
      cout << "Unknown object type, name: " 
           << obj->GetName() << " title: " << obj->GetTitle() << endl;
    }
    
    // now write the merged histogram (which is "in" obj) to the target file
    // note that this will just store obj in the current directory level,
    // which is not persistent until the complete directory itself is stored
    // by "target->Write()" below
    if ( obj ) {
      target->cd();
      
      //!!if the object is a tree, it is stored in globChain...
      if(obj->IsA()->InheritsFrom( "TTree" ))
	globChain->Write( key->GetName() );
      else
	obj->Write( key->GetName() );
    }
    
  } // while ( ( TKey *key = (TKey*)nextkey() ) )
  
  // save modifications to target file
  target->Write();
  
}


/*

  This macro will add histograms from a list of root files and write them
  to a target root file. The target file is newly created and must not be
  identical to one of the source files.

  Author: Sven A. Schmidt, sven.schmidt@cern.ch
  Date:   13.2.2001

  This code is based on the hadd.C example by Rene Brun and Dirk Geppert,
  which had a problem with directories more than one level deep.
  (see macro hadd_old.C for this previous implementation).
  
  The macro from Sven has been enhanced by 
     Anne-Sylvie Nicollerat <Anne-Sylvie.Nicollerat@cern.ch>
   to automatically add Trees (via a chain of trees).
  
  To use this macro, modify the file names in function hadd.
  
  NB: This macro is provided as a tutorial.
      Use $ROOTSYS/bin/hadd to merge many histogram files

 */



// $Log: haddWana.C,v $
// Revision 1.18  2010/05/19 20:49:50  balewski
// removed 5 runs tagged by Ross
//
// Revision 1.17  2010/03/15 17:05:51  balewski
// cleanup, used for W AL sort March 15, 2010
//
// Revision 1.16  2010/03/14 19:37:27  balewski
// Removed F10383, has TPC problem according to Gene
//
// Revision 1.15  2010/02/24 18:26:24  balewski
// added macros computing/plotting AL
//
// Revision 1.14  2010/02/06 01:12:46  balewski
// skips unpol CNI fills
//
// Revision 1.13  2010/02/04 03:48:25  balewski
// add ET for lumi monitor
//
// Revision 1.12  2010/01/27 22:12:26  balewski
// spin code matched to x-section code
//
// Revision 1.11  2010/01/10 03:01:39  balewski
// cleanup & nicer histos
//
// Revision 1.10  2010/01/06 05:21:59  balewski
// cleanup
//
// Revision 1.9  2010/01/06 04:22:18  balewski
// added Q/PT plot for Zs, more cleanup
//
// Revision 1.8  2010/01/05 03:23:02  balewski
// change logic for filling btow status tables, added printout to Z-code
//
// Revision 1.7  2010/01/04 05:12:02  balewski
// added 4x4 cut to Z-algo, cleanup
//
// Revision 1.6  2010/01/03 04:38:27  balewski
// reorganized Z-algo
//
// Revision 1.5  2010/01/03 01:58:19  balewski
// run list for setABCD updated to SL09g
//
// Revision 1.4  2009/12/30 18:27:52  balewski
// after tag I added a test line
//
// Revision 1.3  2009/12/30 18:27:02  balewski
// added tag for testing
//
// Revision 1.2  2009/12/08 16:53:01  balewski
// *** empty log message ***
//
// Revision 1.1  2009/11/23 23:00:20  balewski
// code moved spin-pool
//
